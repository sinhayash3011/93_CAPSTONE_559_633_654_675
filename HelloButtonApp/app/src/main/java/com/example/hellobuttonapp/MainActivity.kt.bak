package com.example.hellobuttonapp

import android.Manifest
import android.content.pm.PackageManager
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.location.Location
import android.location.LocationListener
import android.location.LocationManager
import android.os.Build
import android.os.Bundle
import android.widget.Button
import android.widget.TextView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import java.io.IOException
import java.util.concurrent.TimeUnit

class MainActivity : AppCompatActivity(), SensorEventListener {

    companion object {
        // --- CHANGE THIS to your Mac LAN IP when testing on a REAL PHONE ---
        // Example for real phone over LAN: "http://192.168.1.165:5001"
        // For adb reverse on real phone: use "http://127.0.0.1:5001"
        // For emulator: 10.0.2.2 is used automatically
        private const val SERVER_URL_MANUAL = "http://10.0.2.2:5001"

        // JSON MediaType constant used everywhere
        private val JSON = "application/json; charset=utf-8".toMediaType()
    }

    // final base url used by requests (may be adjusted for emulator)
    private val BASE_URL: String by lazy {
        if (isRunningOnEmulator()) {
            // emulator -> host alias
            "http://10.0.2.2:5001"
        } else {
            SERVER_URL_MANUAL
        }
    }

    private val client by lazy {
        OkHttpClient.Builder()
            .callTimeout(8, TimeUnit.SECONDS)
            .connectTimeout(6, TimeUnit.SECONDS)
            .readTimeout(8, TimeUnit.SECONDS)
            .build()
    }

    // UI
    private lateinit var btnGps: Button
    private lateinit var btnModel: Button
    private lateinit var tvGpsResult: TextView
    private lateinit var tvModelResult: TextView
    private lateinit var tvStatus: TextView

    // Sensors & streaming
    private lateinit var sensorManager: SensorManager
    private var streamingJob: Job? = null

    // latest sensor values (float)
    @Volatile private var ax = 0f
    @Volatile private var ay = 0f
    @Volatile private var az = 0f
    @Volatile private var gx = 0f
    @Volatile private var gy = 0f
    @Volatile private var gz = 0f
    @Volatile private var mx = 0f
    @Volatile private var my = 0f
    @Volatile private var mz = 0f

    // Location manager (for optional GPS labels)
    private var locationManager: LocationManager? = null
    private var lastLocation: Location? = null

    // permission launcher (location)
    private val requestPermissionLauncher =
        registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { perms ->
            // simple handling
            val ok = perms[Manifest.permission.ACCESS_FINE_LOCATION] == true
            if (!ok) {
                Toast.makeText(this, "Location permission required to include GPS labels.", Toast.LENGTH_SHORT).show()
            } else {
                startLocationListener()
            }
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // UI bindings (ensure IDs exist in your layout)
        btnGps = findViewById(R.id.btnGps)
        btnModel = findViewById(R.id.btnModel)
        tvGpsResult = findViewById(R.id.tvGpsResult)
        tvModelResult = findViewById(R.id.tvModelResult)
        tvStatus = findViewById(R.id.tvStatus)

        // Sensor manager
        sensorManager = getSystemService(SENSOR_SERVICE) as SensorManager

        // Location manager
        locationManager = getSystemService(LOCATION_SERVICE) as LocationManager

        // Ask for location permission (runtime)
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            requestPermissionLauncher.launch(arrayOf(Manifest.permission.ACCESS_FINE_LOCATION))
        } else {
            startLocationListener()
        }

        // Buttons
        btnGps.setOnClickListener {
            tvStatus.text = "Requesting GPS from server..."
            sendGpsRequest()
        }

        btnModel.setOnClickListener {
            tvStatus.text = "Asking server for ML prediction..."
            sendModelRequest()
        }

        // Check server reachability
        lifecycleScope.launch {
            updateServerStatus()
        }
    }

    override fun onResume() {
        super.onResume()

        // Register sensors (SENSOR_DELAY_GAME is ~50ms; we stream at ~100ms below)
        sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)?.also {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_GAME)
        }
        sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE)?.also {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_GAME)
        }
        sensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)?.also {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_GAME)
        }

        // Start streaming coroutine (if not running already)
        if (streamingJob == null) {
            streamingJob = lifecycleScope.launch {
                // stream until cancelled
                while (true) {
                    sendStreamPacket()
                    delay(100) // 10 Hz streaming
                }
            }
        }
    }

    override fun onPause() {
        super.onPause()
        // Stop streaming while paused (you can keep it running if using foreground service)
        streamingJob?.cancel()
        streamingJob = null
        sensorManager.unregisterListener(this)
        // stop location updates to save battery
        stopLocationListener()
    }

    override fun onDestroy() {
        super.onDestroy()
        streamingJob?.cancel()
    }

    // Simple emulator detection
    private fun isRunningOnEmulator(): Boolean {
        return (Build.FINGERPRINT.startsWith("generic")
                || Build.FINGERPRINT.lowercase().contains("vbox")
                || Build.FINGERPRINT.lowercase().contains("test-keys")
                || Build.MODEL.contains("Emulator")
                || Build.MODEL.contains("Android SDK built for x86"))
    }

    // ---------------------------
    // SensorEventListener methods
    // ---------------------------
    override fun onSensorChanged(event: SensorEvent?) {
        if (event == null) return
        when (event.sensor.type) {
            Sensor.TYPE_ACCELEROMETER -> {
                ax = event.values[0]
                ay = event.values[1]
                az = event.values[2]
            }
            Sensor.TYPE_GYROSCOPE -> {
                gx = event.values[0]
                gy = event.values[1]
                gz = event.values[2]
            }
            Sensor.TYPE_MAGNETIC_FIELD -> {
                mx = event.values[0]
                my = event.values[1]
                mz = event.values[2]
            }
        }
    }

    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {
        // ignore
    }

    // ---------------------------
    // Location helper (optional)
    // ---------------------------
    private fun startLocationListener() {
        try {
            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
                return
            }
            locationManager?.requestLocationUpdates(LocationManager.GPS_PROVIDER, 1000L, 0f, locationListener)
            // Also try network provider for faster coarse location
            locationManager?.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 1000L, 0f, locationListener)
        } catch (e: Exception) {
            // ignore
        }
    }

    private fun stopLocationListener() {
        try {
            locationManager?.removeUpdates(locationListener)
        } catch (e: Exception) {
            // ignore
        }
    }

    private val locationListener = object : LocationListener {
        override fun onLocationChanged(location: Location) {
            lastLocation = location
        }
        override fun onProviderEnabled(provider: String) {}
        override fun onProviderDisabled(provider: String) {}
        override fun onStatusChanged(provider: String?, status: Int, extras: Bundle?) {}
    }

    // ---------------------------
    // Networking: stream IMU packet
    // ---------------------------
    private suspend fun sendStreamPacket() = withContext(Dispatchers.IO) {
        try {
            // Build JSON payload
            val json = JSONObject()
            val sample = JSONObject()
            sample.put("ax", ax.toDouble())
            sample.put("ay", ay.toDouble())
            sample.put("az", az.toDouble())
            sample.put("gx", gx.toDouble())
            sample.put("gy", gy.toDouble())
            sample.put("gz", gz.toDouble())
            sample.put("mx", mx.toDouble())
            sample.put("my", my.toDouble())
            sample.put("mz", mz.toDouble())
            json.put("sample", sample)
            json.put("timestamp", System.currentTimeMillis() / 1000.0)

            // include gps if we have a reasonably recent location
            lastLocation?.let {
                val gps = JSONObject()
                gps.put("lat", it.latitude)
                gps.put("lon", it.longitude)
                json.put("gps", gps)
            }

            val body = json.toString().toRequestBody(JSON)
            val req = Request.Builder()
                .url("$BASE_URL/stream")
                .post(body)
                .build()

            client.newCall(req).execute().use { resp ->
                // We don't need to parse reply here — server replies with small JSON.
                // Optionally update UI status occasionally (not every packet to avoid UI thrash).
            }
        } catch (e: IOException) {
            // network issue — ignore here (could implement retry/backoff)
        } catch (e: Exception) {
            // ignore any other exceptions
        }
    }

    // ---------------------------
    // Existing GPS & MODEL requests
    // ---------------------------
    private fun sendGpsRequest() {
        lifecycleScope.launch(Dispatchers.IO) {
            val url = "$BASE_URL/gps"
            val reqBody = "{}".toRequestBody(JSON)
            val req = Request.Builder().url(url).post(reqBody).build()

            try {
                client.newCall(req).execute().use { resp ->
                    val text = resp.body?.string()
                    if (!resp.isSuccessful) {
                        withContext(Dispatchers.Main) {
                            tvStatus.text = "Server returned ${resp.code}"
                            Toast.makeText(this@MainActivity, "GPS request failed: ${resp.code}", Toast.LENGTH_SHORT).show()
                        }
                    } else {
                        val latLon = parseGpsFromResponse(text)
                        withContext(Dispatchers.Main) {
                            tvGpsResult.text = latLon ?: "GPS: (no data)"
                            tvStatus.text = "GPS OK"
                        }
                    }
                }
            } catch (e: IOException) {
                withContext(Dispatchers.Main) {
                    tvStatus.text = "Network error"
                    Toast.makeText(this@MainActivity, "Network error: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private fun sendModelRequest() {
        lifecycleScope.launch(Dispatchers.IO) {
            val url = "$BASE_URL/predict"
            val reqBody = "{}".toRequestBody(JSON)
            val req = Request.Builder().url(url).post(reqBody).build()

            try {
                client.newCall(req).execute().use { resp ->
                    val text = resp.body?.string()
                    if (!resp.isSuccessful) {
                        withContext(Dispatchers.Main) {
                            tvStatus.text = "Model request failed: ${resp.code}"
                            Toast.makeText(this@MainActivity, "Model failed: ${resp.code}", Toast.LENGTH_SHORT).show()
                        }
                    } else {
                        val modelRes = parseModelFromResponse(text)
                        withContext(Dispatchers.Main) {
                            tvModelResult.text = modelRes ?: "Model: (no data)"
                            tvStatus.text = "Model OK"
                        }
                    }
                }
            } catch (e: IOException) {
                withContext(Dispatchers.Main) {
                    tvStatus.text = "Network error"
                    Toast.makeText(this@MainActivity, "Network error: ${e.message}", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    private suspend fun updateServerStatus() = withContext(Dispatchers.IO) {
        val url = "$BASE_URL/status"
        val req = Request.Builder().url(url).get().build()
        try {
            client.newCall(req).execute().use { resp ->
                val text = resp.body?.string()
                withContext(Dispatchers.Main) {
                    if (resp.isSuccessful && !text.isNullOrBlank()) {
                        tvStatus.text = "Server: reachable"
                    } else {
                        tvStatus.text = "Server: unreachable"
                    }
                }
            }
        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                tvStatus.text = "Server: network error"
            }
        }
    }

    // ---------------------------
    // Response parsers (same as before)
    // ---------------------------
    private fun parseGpsFromResponse(body: String?): String? {
        if (body.isNullOrBlank()) return null
        return try {
            val jo = JSONObject(body)
            val lat = when {
                jo.has("lat") -> jo.getDouble("lat")
                jo.has("gps") -> jo.optJSONObject("gps")?.optDouble("lat") ?: Double.NaN
                else -> Double.NaN
            }
            val lon = when {
                jo.has("lon") -> jo.getDouble("lon")
                jo.has("gps") -> jo.optJSONObject("gps")?.optDouble("lon") ?: Double.NaN
                else -> Double.NaN
            }
            if (!lat.isNaN() && !lon.isNaN()) "GPS: $lat , $lon" else body
        } catch (e: Exception) {
            body
        }
    }

    private fun parseModelFromResponse(body: String?): String? {
        if (body.isNullOrBlank()) return null
        return try {
            val jo = JSONObject(body)
            if (jo.has("lat") && jo.has("lon")) {
                "Model: ${jo.getDouble("lat")} , ${jo.getDouble("lon")}"
            } else {
                jo.optString("message", body)
            }
        } catch (e: Exception) {
            body
        }
    }
}
